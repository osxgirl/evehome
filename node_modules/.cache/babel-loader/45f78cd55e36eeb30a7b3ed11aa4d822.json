{"ast":null,"code":"'use strict';\n\nconst Stream = require('stream').Stream;\n\nconst fetch = require('../fetch');\n\nconst crypto = require('crypto');\n\nconst shared = require('../shared');\n/**\n * XOAUTH2 access_token generator for Gmail.\n * Create client ID for web applications in Google API console to use it.\n * See Offline Access for receiving the needed refreshToken for an user\n * https://developers.google.com/accounts/docs/OAuth2WebServer#offline\n *\n * Usage for generating access tokens with a custom method using provisionCallback:\n * provisionCallback(user, renew, callback)\n *   * user is the username to get the token for\n *   * renew is a boolean that if true indicates that existing token failed and needs to be renewed\n *   * callback is the callback to run with (error, accessToken [, expires])\n *     * accessToken is a string\n *     * expires is an optional expire time in milliseconds\n * If provisionCallback is used, then Nodemailer does not try to attempt generating the token by itself\n *\n * @constructor\n * @param {Object} options Client information for token generation\n * @param {String} options.user User e-mail address\n * @param {String} options.clientId Client ID value\n * @param {String} options.clientSecret Client secret value\n * @param {String} options.refreshToken Refresh token for an user\n * @param {String} options.accessUrl Endpoint for token generation, defaults to 'https://accounts.google.com/o/oauth2/token'\n * @param {String} options.accessToken An existing valid accessToken\n * @param {String} options.privateKey Private key for JSW\n * @param {Number} options.expires Optional Access Token expire time in ms\n * @param {Number} options.timeout Optional TTL for Access Token in seconds\n * @param {Function} options.provisionCallback Function to run when a new access token is required\n */\n\n\nclass XOAuth2 extends Stream {\n  constructor(options, logger) {\n    super();\n    this.options = options || {};\n\n    if (options && options.serviceClient) {\n      if (!options.privateKey || !options.user) {\n        setImmediate(() => this.emit('error', new Error('Options \"privateKey\" and \"user\" are required for service account!')));\n        return;\n      }\n\n      let serviceRequestTimeout = Math.min(Math.max(Number(this.options.serviceRequestTimeout) || 0, 0), 3600);\n      this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;\n    }\n\n    this.logger = shared.getLogger({\n      logger\n    }, {\n      component: this.options.component || 'OAuth2'\n    });\n    this.provisionCallback = typeof this.options.provisionCallback === 'function' ? this.options.provisionCallback : false;\n    this.options.accessUrl = this.options.accessUrl || 'https://accounts.google.com/o/oauth2/token';\n    this.options.customHeaders = this.options.customHeaders || {};\n    this.options.customParams = this.options.customParams || {};\n    this.accessToken = this.options.accessToken || false;\n\n    if (this.options.expires && Number(this.options.expires)) {\n      this.expires = this.options.expires;\n    } else {\n      let timeout = Math.max(Number(this.options.timeout) || 0, 0);\n      this.expires = timeout && Date.now() + timeout * 1000 || 0;\n    }\n  }\n  /**\n   * Returns or generates (if previous has expired) a XOAuth2 token\n   *\n   * @param {Boolean} renew If false then use cached access token (if available)\n   * @param {Function} callback Callback function with error object and token string\n   */\n\n\n  getToken(renew, callback) {\n    var _this = this;\n\n    if (!renew && this.accessToken && (!this.expires || this.expires > Date.now())) {\n      return callback(null, this.accessToken);\n    }\n\n    let generateCallback = function () {\n      if (arguments.length <= 0 ? undefined : arguments[0]) {\n        _this.logger.error({\n          err: arguments.length <= 0 ? undefined : arguments[0],\n          tnx: 'OAUTH2',\n          user: _this.options.user,\n          action: 'renew'\n        }, 'Failed generating new Access Token for %s', _this.options.user);\n      } else {\n        _this.logger.info({\n          tnx: 'OAUTH2',\n          user: _this.options.user,\n          action: 'renew'\n        }, 'Generated new Access Token for %s', _this.options.user);\n      }\n\n      callback(...arguments);\n    };\n\n    if (this.provisionCallback) {\n      this.provisionCallback(this.options.user, !!renew, (err, accessToken, expires) => {\n        if (!err && accessToken) {\n          this.accessToken = accessToken;\n          this.expires = expires || 0;\n        }\n\n        generateCallback(err, accessToken);\n      });\n    } else {\n      this.generateToken(generateCallback);\n    }\n  }\n  /**\n   * Updates token values\n   *\n   * @param {String} accessToken New access token\n   * @param {Number} timeout Access token lifetime in seconds\n   *\n   * Emits 'token': { user: User email-address, accessToken: the new accessToken, timeout: TTL in seconds}\n   */\n\n\n  updateToken(accessToken, timeout) {\n    this.accessToken = accessToken;\n    timeout = Math.max(Number(timeout) || 0, 0);\n    this.expires = timeout && Date.now() + timeout * 1000 || 0;\n    this.emit('token', {\n      user: this.options.user,\n      accessToken: accessToken || '',\n      expires: this.expires\n    });\n  }\n  /**\n   * Generates a new XOAuth2 token with the credentials provided at initialization\n   *\n   * @param {Function} callback Callback function with error object and token string\n   */\n\n\n  generateToken(callback) {\n    let urlOptions;\n    let loggedUrlOptions;\n\n    if (this.options.serviceClient) {\n      // service account - https://developers.google.com/identity/protocols/OAuth2ServiceAccount\n      let iat = Math.floor(Date.now() / 1000); // unix time\n\n      let tokenData = {\n        iss: this.options.serviceClient,\n        scope: this.options.scope || 'https://mail.google.com/',\n        sub: this.options.user,\n        aud: this.options.accessUrl,\n        iat,\n        exp: iat + this.options.serviceRequestTimeout\n      };\n      let token;\n\n      try {\n        token = this.jwtSignRS256(tokenData);\n      } catch (err) {\n        return callback(new Error('Can\\x27t generate token. Check your auth options'));\n      }\n\n      urlOptions = {\n        grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n        assertion: token\n      };\n      loggedUrlOptions = {\n        grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n        assertion: tokenData\n      };\n    } else {\n      if (!this.options.refreshToken) {\n        return callback(new Error('Can\\x27t create new access token for user'));\n      } // web app - https://developers.google.com/identity/protocols/OAuth2WebServer\n\n\n      urlOptions = {\n        client_id: this.options.clientId || '',\n        client_secret: this.options.clientSecret || '',\n        refresh_token: this.options.refreshToken,\n        grant_type: 'refresh_token'\n      };\n      loggedUrlOptions = {\n        client_id: this.options.clientId || '',\n        client_secret: (this.options.clientSecret || '').substr(0, 6) + '...',\n        refresh_token: (this.options.refreshToken || '').substr(0, 6) + '...',\n        grant_type: 'refresh_token'\n      };\n    }\n\n    Object.keys(this.options.customParams).forEach(key => {\n      urlOptions[key] = this.options.customParams[key];\n      loggedUrlOptions[key] = this.options.customParams[key];\n    });\n    this.logger.debug({\n      tnx: 'OAUTH2',\n      user: this.options.user,\n      action: 'generate'\n    }, 'Requesting token using: %s', JSON.stringify(loggedUrlOptions));\n    this.postRequest(this.options.accessUrl, urlOptions, this.options, (error, body) => {\n      let data;\n\n      if (error) {\n        return callback(error);\n      }\n\n      try {\n        data = JSON.parse(body.toString());\n      } catch (E) {\n        return callback(E);\n      }\n\n      if (!data || typeof data !== 'object') {\n        this.logger.debug({\n          tnx: 'OAUTH2',\n          user: this.options.user,\n          action: 'post'\n        }, 'Response: %s', (body || '').toString());\n        return callback(new Error('Invalid authentication response'));\n      }\n\n      let logData = {};\n      Object.keys(data).forEach(key => {\n        if (key !== 'access_token') {\n          logData[key] = data[key];\n        } else {\n          logData[key] = (data[key] || '').toString().substr(0, 6) + '...';\n        }\n      });\n      this.logger.debug({\n        tnx: 'OAUTH2',\n        user: this.options.user,\n        action: 'post'\n      }, 'Response: %s', JSON.stringify(logData));\n\n      if (data.error) {\n        // Error Response : https://tools.ietf.org/html/rfc6749#section-5.2\n        let errorMessage = data.error;\n\n        if (data.error_description) {\n          errorMessage += ': ' + data.error_description;\n        }\n\n        if (data.error_uri) {\n          errorMessage += ' (' + data.error_uri + ')';\n        }\n\n        return callback(new Error(errorMessage));\n      }\n\n      if (data.access_token) {\n        this.updateToken(data.access_token, data.expires_in);\n        return callback(null, this.accessToken);\n      }\n\n      return callback(new Error('No access token'));\n    });\n  }\n  /**\n   * Converts an access_token and user id into a base64 encoded XOAuth2 token\n   *\n   * @param {String} [accessToken] Access token string\n   * @return {String} Base64 encoded token for IMAP or SMTP login\n   */\n\n\n  buildXOAuth2Token(accessToken) {\n    let authData = ['user=' + (this.options.user || ''), 'auth=Bearer ' + (accessToken || this.accessToken), '', ''];\n    return Buffer.from(authData.join('\\x01'), 'utf-8').toString('base64');\n  }\n  /**\n   * Custom POST request handler.\n   * This is only needed to keep paths short in Windows â€“ usually this module\n   * is a dependency of a dependency and if it tries to require something\n   * like the request module the paths get way too long to handle for Windows.\n   * As we do only a simple POST request we do not actually require complicated\n   * logic support (no redirects, no nothing) anyway.\n   *\n   * @param {String} url Url to POST to\n   * @param {String|Buffer} payload Payload to POST\n   * @param {Function} callback Callback function with (err, buff)\n   */\n\n\n  postRequest(url, payload, params, callback) {\n    let returned = false;\n    let chunks = [];\n    let chunklen = 0;\n    let req = fetch(url, {\n      method: 'post',\n      headers: params.customHeaders,\n      body: payload,\n      allowErrorResponse: true\n    });\n    req.on('readable', () => {\n      let chunk;\n\n      while ((chunk = req.read()) !== null) {\n        chunks.push(chunk);\n        chunklen += chunk.length;\n      }\n    });\n    req.once('error', err => {\n      if (returned) {\n        return;\n      }\n\n      returned = true;\n      return callback(err);\n    });\n    req.once('end', () => {\n      if (returned) {\n        return;\n      }\n\n      returned = true;\n      return callback(null, Buffer.concat(chunks, chunklen));\n    });\n  }\n  /**\n   * Encodes a buffer or a string into Base64url format\n   *\n   * @param {Buffer|String} data The data to convert\n   * @return {String} The encoded string\n   */\n\n\n  toBase64URL(data) {\n    if (typeof data === 'string') {\n      data = Buffer.from(data);\n    }\n\n    return data.toString('base64').replace(/[=]+/g, '') // remove '='s\n    .replace(/\\+/g, '-') // '+' â†’ '-'\n    .replace(/\\//g, '_'); // '/' â†’ '_'\n  }\n  /**\n   * Creates a JSON Web Token signed with RS256 (SHA256 + RSA)\n   *\n   * @param {Object} payload The payload to include in the generated token\n   * @return {String} The generated and signed token\n   */\n\n\n  jwtSignRS256(payload) {\n    payload = ['{\"alg\":\"RS256\",\"typ\":\"JWT\"}', JSON.stringify(payload)].map(val => this.toBase64URL(val)).join('.');\n    let signature = crypto.createSign('RSA-SHA256').update(payload).sign(this.options.privateKey);\n    return payload + '.' + this.toBase64URL(signature);\n  }\n\n}\n\nmodule.exports = XOAuth2;","map":{"version":3,"sources":["/Users/heather/Development/code/evehome/node_modules/nodemailer/lib/xoauth2/index.js"],"names":["Stream","require","fetch","crypto","shared","XOAuth2","constructor","options","logger","serviceClient","privateKey","user","setImmediate","emit","Error","serviceRequestTimeout","Math","min","max","Number","getLogger","component","provisionCallback","accessUrl","customHeaders","customParams","accessToken","expires","timeout","Date","now","getToken","renew","callback","generateCallback","error","err","tnx","action","info","generateToken","updateToken","urlOptions","loggedUrlOptions","iat","floor","tokenData","iss","scope","sub","aud","exp","token","jwtSignRS256","grant_type","assertion","refreshToken","client_id","clientId","client_secret","clientSecret","refresh_token","substr","Object","keys","forEach","key","debug","JSON","stringify","postRequest","body","data","parse","toString","E","logData","errorMessage","error_description","error_uri","access_token","expires_in","buildXOAuth2Token","authData","Buffer","from","join","url","payload","params","returned","chunks","chunklen","req","method","headers","allowErrorResponse","on","chunk","read","push","length","once","concat","toBase64URL","replace","map","val","signature","createSign","update","sign","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Stream = require('stream').Stream;\nconst fetch = require('../fetch');\nconst crypto = require('crypto');\nconst shared = require('../shared');\n\n/**\n * XOAUTH2 access_token generator for Gmail.\n * Create client ID for web applications in Google API console to use it.\n * See Offline Access for receiving the needed refreshToken for an user\n * https://developers.google.com/accounts/docs/OAuth2WebServer#offline\n *\n * Usage for generating access tokens with a custom method using provisionCallback:\n * provisionCallback(user, renew, callback)\n *   * user is the username to get the token for\n *   * renew is a boolean that if true indicates that existing token failed and needs to be renewed\n *   * callback is the callback to run with (error, accessToken [, expires])\n *     * accessToken is a string\n *     * expires is an optional expire time in milliseconds\n * If provisionCallback is used, then Nodemailer does not try to attempt generating the token by itself\n *\n * @constructor\n * @param {Object} options Client information for token generation\n * @param {String} options.user User e-mail address\n * @param {String} options.clientId Client ID value\n * @param {String} options.clientSecret Client secret value\n * @param {String} options.refreshToken Refresh token for an user\n * @param {String} options.accessUrl Endpoint for token generation, defaults to 'https://accounts.google.com/o/oauth2/token'\n * @param {String} options.accessToken An existing valid accessToken\n * @param {String} options.privateKey Private key for JSW\n * @param {Number} options.expires Optional Access Token expire time in ms\n * @param {Number} options.timeout Optional TTL for Access Token in seconds\n * @param {Function} options.provisionCallback Function to run when a new access token is required\n */\nclass XOAuth2 extends Stream {\n    constructor(options, logger) {\n        super();\n\n        this.options = options || {};\n\n        if (options && options.serviceClient) {\n            if (!options.privateKey || !options.user) {\n                setImmediate(() => this.emit('error', new Error('Options \"privateKey\" and \"user\" are required for service account!')));\n                return;\n            }\n\n            let serviceRequestTimeout = Math.min(Math.max(Number(this.options.serviceRequestTimeout) || 0, 0), 3600);\n            this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;\n        }\n\n        this.logger = shared.getLogger(\n            {\n                logger\n            },\n            {\n                component: this.options.component || 'OAuth2'\n            }\n        );\n\n        this.provisionCallback = typeof this.options.provisionCallback === 'function' ? this.options.provisionCallback : false;\n\n        this.options.accessUrl = this.options.accessUrl || 'https://accounts.google.com/o/oauth2/token';\n        this.options.customHeaders = this.options.customHeaders || {};\n        this.options.customParams = this.options.customParams || {};\n\n        this.accessToken = this.options.accessToken || false;\n\n        if (this.options.expires && Number(this.options.expires)) {\n            this.expires = this.options.expires;\n        } else {\n            let timeout = Math.max(Number(this.options.timeout) || 0, 0);\n            this.expires = (timeout && Date.now() + timeout * 1000) || 0;\n        }\n    }\n\n    /**\n     * Returns or generates (if previous has expired) a XOAuth2 token\n     *\n     * @param {Boolean} renew If false then use cached access token (if available)\n     * @param {Function} callback Callback function with error object and token string\n     */\n    getToken(renew, callback) {\n        if (!renew && this.accessToken && (!this.expires || this.expires > Date.now())) {\n            return callback(null, this.accessToken);\n        }\n\n        let generateCallback = (...args) => {\n            if (args[0]) {\n                this.logger.error(\n                    {\n                        err: args[0],\n                        tnx: 'OAUTH2',\n                        user: this.options.user,\n                        action: 'renew'\n                    },\n                    'Failed generating new Access Token for %s',\n                    this.options.user\n                );\n            } else {\n                this.logger.info(\n                    {\n                        tnx: 'OAUTH2',\n                        user: this.options.user,\n                        action: 'renew'\n                    },\n                    'Generated new Access Token for %s',\n                    this.options.user\n                );\n            }\n            callback(...args);\n        };\n\n        if (this.provisionCallback) {\n            this.provisionCallback(this.options.user, !!renew, (err, accessToken, expires) => {\n                if (!err && accessToken) {\n                    this.accessToken = accessToken;\n                    this.expires = expires || 0;\n                }\n                generateCallback(err, accessToken);\n            });\n        } else {\n            this.generateToken(generateCallback);\n        }\n    }\n\n    /**\n     * Updates token values\n     *\n     * @param {String} accessToken New access token\n     * @param {Number} timeout Access token lifetime in seconds\n     *\n     * Emits 'token': { user: User email-address, accessToken: the new accessToken, timeout: TTL in seconds}\n     */\n    updateToken(accessToken, timeout) {\n        this.accessToken = accessToken;\n        timeout = Math.max(Number(timeout) || 0, 0);\n        this.expires = (timeout && Date.now() + timeout * 1000) || 0;\n\n        this.emit('token', {\n            user: this.options.user,\n            accessToken: accessToken || '',\n            expires: this.expires\n        });\n    }\n\n    /**\n     * Generates a new XOAuth2 token with the credentials provided at initialization\n     *\n     * @param {Function} callback Callback function with error object and token string\n     */\n    generateToken(callback) {\n        let urlOptions;\n        let loggedUrlOptions;\n        if (this.options.serviceClient) {\n            // service account - https://developers.google.com/identity/protocols/OAuth2ServiceAccount\n            let iat = Math.floor(Date.now() / 1000); // unix time\n            let tokenData = {\n                iss: this.options.serviceClient,\n                scope: this.options.scope || 'https://mail.google.com/',\n                sub: this.options.user,\n                aud: this.options.accessUrl,\n                iat,\n                exp: iat + this.options.serviceRequestTimeout\n            };\n            let token;\n            try {\n                token = this.jwtSignRS256(tokenData);\n            } catch (err) {\n                return callback(new Error('Can\\x27t generate token. Check your auth options'));\n            }\n\n            urlOptions = {\n                grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n                assertion: token\n            };\n\n            loggedUrlOptions = {\n                grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n                assertion: tokenData\n            };\n        } else {\n            if (!this.options.refreshToken) {\n                return callback(new Error('Can\\x27t create new access token for user'));\n            }\n\n            // web app - https://developers.google.com/identity/protocols/OAuth2WebServer\n            urlOptions = {\n                client_id: this.options.clientId || '',\n                client_secret: this.options.clientSecret || '',\n                refresh_token: this.options.refreshToken,\n                grant_type: 'refresh_token'\n            };\n\n            loggedUrlOptions = {\n                client_id: this.options.clientId || '',\n                client_secret: (this.options.clientSecret || '').substr(0, 6) + '...',\n                refresh_token: (this.options.refreshToken || '').substr(0, 6) + '...',\n                grant_type: 'refresh_token'\n            };\n        }\n\n        Object.keys(this.options.customParams).forEach(key => {\n            urlOptions[key] = this.options.customParams[key];\n            loggedUrlOptions[key] = this.options.customParams[key];\n        });\n\n        this.logger.debug(\n            {\n                tnx: 'OAUTH2',\n                user: this.options.user,\n                action: 'generate'\n            },\n            'Requesting token using: %s',\n            JSON.stringify(loggedUrlOptions)\n        );\n\n        this.postRequest(this.options.accessUrl, urlOptions, this.options, (error, body) => {\n            let data;\n\n            if (error) {\n                return callback(error);\n            }\n\n            try {\n                data = JSON.parse(body.toString());\n            } catch (E) {\n                return callback(E);\n            }\n\n            if (!data || typeof data !== 'object') {\n                this.logger.debug(\n                    {\n                        tnx: 'OAUTH2',\n                        user: this.options.user,\n                        action: 'post'\n                    },\n                    'Response: %s',\n                    (body || '').toString()\n                );\n                return callback(new Error('Invalid authentication response'));\n            }\n\n            let logData = {};\n            Object.keys(data).forEach(key => {\n                if (key !== 'access_token') {\n                    logData[key] = data[key];\n                } else {\n                    logData[key] = (data[key] || '').toString().substr(0, 6) + '...';\n                }\n            });\n\n            this.logger.debug(\n                {\n                    tnx: 'OAUTH2',\n                    user: this.options.user,\n                    action: 'post'\n                },\n                'Response: %s',\n                JSON.stringify(logData)\n            );\n\n            if (data.error) {\n                // Error Response : https://tools.ietf.org/html/rfc6749#section-5.2\n                let errorMessage = data.error;\n                if (data.error_description) {\n                    errorMessage += ': ' + data.error_description;\n                }\n                if (data.error_uri) {\n                    errorMessage += ' (' + data.error_uri + ')';\n                }\n                return callback(new Error(errorMessage));\n            }\n\n            if (data.access_token) {\n                this.updateToken(data.access_token, data.expires_in);\n                return callback(null, this.accessToken);\n            }\n\n            return callback(new Error('No access token'));\n        });\n    }\n\n    /**\n     * Converts an access_token and user id into a base64 encoded XOAuth2 token\n     *\n     * @param {String} [accessToken] Access token string\n     * @return {String} Base64 encoded token for IMAP or SMTP login\n     */\n    buildXOAuth2Token(accessToken) {\n        let authData = ['user=' + (this.options.user || ''), 'auth=Bearer ' + (accessToken || this.accessToken), '', ''];\n        return Buffer.from(authData.join('\\x01'), 'utf-8').toString('base64');\n    }\n\n    /**\n     * Custom POST request handler.\n     * This is only needed to keep paths short in Windows â€“ usually this module\n     * is a dependency of a dependency and if it tries to require something\n     * like the request module the paths get way too long to handle for Windows.\n     * As we do only a simple POST request we do not actually require complicated\n     * logic support (no redirects, no nothing) anyway.\n     *\n     * @param {String} url Url to POST to\n     * @param {String|Buffer} payload Payload to POST\n     * @param {Function} callback Callback function with (err, buff)\n     */\n    postRequest(url, payload, params, callback) {\n        let returned = false;\n\n        let chunks = [];\n        let chunklen = 0;\n\n        let req = fetch(url, {\n            method: 'post',\n            headers: params.customHeaders,\n            body: payload,\n            allowErrorResponse: true\n        });\n\n        req.on('readable', () => {\n            let chunk;\n            while ((chunk = req.read()) !== null) {\n                chunks.push(chunk);\n                chunklen += chunk.length;\n            }\n        });\n\n        req.once('error', err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            return callback(err);\n        });\n\n        req.once('end', () => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            return callback(null, Buffer.concat(chunks, chunklen));\n        });\n    }\n\n    /**\n     * Encodes a buffer or a string into Base64url format\n     *\n     * @param {Buffer|String} data The data to convert\n     * @return {String} The encoded string\n     */\n    toBase64URL(data) {\n        if (typeof data === 'string') {\n            data = Buffer.from(data);\n        }\n\n        return data\n            .toString('base64')\n            .replace(/[=]+/g, '') // remove '='s\n            .replace(/\\+/g, '-') // '+' â†’ '-'\n            .replace(/\\//g, '_'); // '/' â†’ '_'\n    }\n\n    /**\n     * Creates a JSON Web Token signed with RS256 (SHA256 + RSA)\n     *\n     * @param {Object} payload The payload to include in the generated token\n     * @return {String} The generated and signed token\n     */\n    jwtSignRS256(payload) {\n        payload = ['{\"alg\":\"RS256\",\"typ\":\"JWT\"}', JSON.stringify(payload)].map(val => this.toBase64URL(val)).join('.');\n        let signature = crypto.createSign('RSA-SHA256').update(payload).sign(this.options.privateKey);\n        return payload + '.' + this.toBase64URL(signature);\n    }\n}\n\nmodule.exports = XOAuth2;\n"]},"metadata":{},"sourceType":"script"}